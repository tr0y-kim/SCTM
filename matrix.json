{
    "tactics": {
        "description": "Tactics typically refer to the overarching objectives or goals an adversary wants to achieve. It is the adversary's tactical goal: the reason for performing an action. For example, an adversary may want to achieve credential access."
    }, 
    "techniques": {
        "description": "Techniques represent 'how' an adversary achieves a tactical goal by performing an action. For example, an adversary may dump credentials to achieve credential access."
    },
    "items": [
        {
            "id": "TA0001",
            "title": "Reconnaissance",
            "description": "The adversary is trying to gather information they can use to plan future operations.\n Reconnaissance consists of techniques that involve adversaries actively or passively gathering information that can be used to support targeting. Such information may include details of the victim organization, infrastructure, or staff/personnel. This information can be leveraged by the adversary to aid in other phases of the adversary lifecycle, such as using gathered information to plan and execute Initial Access, to scope and prioritize post-compromise objectives, or to drive and lead further Reconnaissance efforts.",
            "to": "/TA0001",
            "created": "17 October 2018",
            "updated": "19 July 2019",
            "items": [
                {
                    "id": "T0001",
                    "title": "Search Open Websites",
                    "description": "Adversaries may systematically peruse publicly accessible online platforms or domains to gather intelligence on potential targets. Such information, spanning personal to professional details, can often be retrieved from a myriad of online resources, including but not limited to, social media platforms, news portals, or sites delineating business functions, such as recruitment announcements or contract awards. \n In a subsequent context, platforms like dappradar.com, which curate and catalogue smart contract applications, offer a fertile ground for adversaries to engage in reconnaissance activities. These platforms provide structured and detailed insights into the landscape of active smart contracts, potentially revealing vulnerabilities or patterns of interest. An attacker, by leveraging the data available on such websites, can not only refine their strategy but also identify lucrative targets, optimizing their efforts for maximum impact.",
                    "to": "/T0001",
                    "reference": [
                        {
                            "id": "1",
                            "name": "DappRadar",
                            "link": "https://dappradar.com/"
                        },
                        {
                            "id": "2",
                            "name": "Solidity Documentation - Delegatecall / Callcode and Libraries",
                            "link": "https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries"
                        }
                    ]
                },
                {
                    "id": "T0002",
                    "title": "Phishing for Information",
                    "description": "Adversaries may deploy phishing strategies to obtain critical information that can facilitate their targeting efforts. Engaging in such information phishing is an endeavor to deceive individuals into revealing pertinent details, often encompassing credentials or other operationally significant data. This form of phishing is distinct from its more recognized counterpart that focuses on the delivery and execution of malicious payloads, as the primary aim here is information acquisition rather than system compromise. \n To illustrate, many decentralized applications (dApps) often establish dedicated websites to promote and elucidate the functionalities of their smart contract applications. Within these promotional platforms, there tends to be an accumulation of detailed personal data to harness developers' authority for various purposes. The presence of such extensive information, including email addresses and names, can inadvertently provide adversaries with opportunities. Leveraging this data, adversaries can craft meticulously designed phishing campaigns aimed at exfiltrating proprietary code or obtaining unauthorized access to the developers' environment.",
                    "to": "/T0002"
                },
                {
                    "id": "T0003",
                    "title": "Search Blockchain Explorer",
                    "description": "This technique leverages the inherent transparency of blockchain systems, allowing adversaries to employ this method with ease. Not just in Ethereum, but across various cryptocurrencies, information within the blockchain can be readily accessed through individual node programs. For instance, in the context of Ethereum, platforms like Etherscan serve as blockchain explorers that enable users to identify smart contract's bytecode and ABI. Furthermore, developers often provide and display the actual code directly. Consequently, adversaries can employ their proprietary bytecode analyzers or static vulnerability detection tools to extensively comb through the explorer. This facilitates mass identification of potential vulnerabilities, streamlining the process for pinpointing exploitable weak points.",
                    "to": "/T0003",
                    "reference": [
                        {
                            "id": "1",  
                            "name": "etherscan",
                            "link": "https://etherscan.io/"
                        },
                        {
                            "id": "2",
                            "name": "Ethereum Certified Contracts",
                            "link": "https://etherscan.io/contractsVerified"
                        }
                    ]
                }
            ]
        },
        {
            "id": "TA0002",
            "title": "Initial Access",
            "description": "The adversary is trying to get into blockchain network. \nInitial Access consists of techniques that use various entry vectors to gain their initial foothold within a network. Techniques used to gain a foothold include normal way to access blockchain or targeted exploiting weaknesses on mining node servers.",
            "to": "/TA0002",
            "created": "17 October 2018",
            "updated": "19 July 2019",
            "items": [
                {
                    "id": "T0004",
                    "title": "Transactions Consuming Gas",
                    "description": "Any transaction that precipitates a change in the state of the smart contract invariably requires gas. This encompasses invoking functions within the smart contract, deploying a new contract, or transferring ether. Moreover, engaging in operations within the smart contract, whether they are calculations, memory storage, or other tasks, draws upon the computational resources of the network, necessitating the consumption of gas.",
                    "to": "/T0004",
                    "examples": [
                        {
                            "id": "EX0004",
                            "title": "EX0004",
                            "description": "Under Construction...",
                            "to": "/EX0004"
                        }
                    ]
                },
                {
                    "id": "T0046",
                    "title": "Transactions Not Consuming Gas",
                    "description": "Transactions that are solely predicated on querying or retrieving data from the smart contract, devoid of any state alteration, are exempt from gas consumption. Such operations are executed on the local node and do not engender changes to the blockchain state. Smart contracts can emit events, which are special logging functionalities to record state changes or notable activities. These logs does not use gas and are stored in transaction receipts and are crucial for applications to monitor and react to contract activities. Also, computations or operations external to the Ethereum blockchain, termed as off-chain, do not require gas. It is only when the results of these operations are intended to be inscribed onto the blockchain that gas becomes a requisite.",
                    "to": "/T0046",
                    "examples": [
                        {
                            "id": "EX0002",
                            "title": "EXAMPLE 0002",
                            "description": "Under Construction...",
                            "to": "/EX0002"
                        }
                    ]
                },
                {
                    "id": "T0047",
                    "title": "Miner Nodes",
                    "description": "A compromised miner address could exploit vulnerabilities tied to the block variables, as elucidated in the background chapter. Vulnerability types, such as Bad Randomness and Time Manipulation, are particularly susceptible to manipulations by miners, given their capability to alter block timestamps.",
                    "to": "/T0047",
                    "examples": [
                        {
                            "id": "EX0002",
                            "title": "EXAMPLE 0002",
                            "description": "Under Construction...",
                            "to": "/EX0002"
                        }
                    ]
                }
            ]
        },
        {
            "id": "TA0003",
            "title": "Execution",
            "description": "Tactics involves the act of running malicious code or commands on smart contracts of victim, allowing the attacker to carry out their objectives, such as establishing a foothold within the environment.",
            "to": "/TA0003",
            "created": "17 October 2018",
            "updated": "19 July 2019",
            "items": [
                {
                    "id": "T0005",
                    "title": "Delegatecall to Untrusted Callee",
                    "description": "There exists a special variant of a message call, named delegatecall which is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and msg.sender and msg.value do not change their values. This allows a smart contract to dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract.\n Calling into untrusted contracts is very dangerous, as the code at the target address can change any storage values of the caller and has full control over the caller's balance.",
                    "to": "/T0005",
                    "examples": [
                        {
                            "id": "EX0005",
                            "title": "Proxy Using DelegateCall",
                            "description": "Delegatecall is a special variant of a message call. It is almost identical to a regular message call except the target address is executed in the context of the calling contract and msg.sender and msg.value remain the same. Essentially, delegatecall delegates other contracts to modify the calling contract's storage.",
                            "to": "/EX0005"
                        },
                        {
                            "id": "EX0005",
                            "title": "Parity Hacked",
                            "description": "The Parity hack involved a combination of both insecure visibility modifiers and misuse of delegate call with abritrary data. The vulnerable contract's function implemented delegatecall and a function from another contract that could modify ownership was left public. That allowed an attacker to craft the msg.data field to call the vulnerable function.",
                            "to": "/EX0005"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "SWC-112",
                            "link": "https://swcregistry.io/docs/SWC-112/"
                        },
                        {
                            "id": "2",
                            "name": "Solidity Documentation - Delegatecall / Callcode and Libraries",
                            "link": "https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries"
                        },
                        {
                            "id": "3",
                            "name": "How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1) - Delegate Call",
                            "link": "https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d"
                        },
                        {
                            "id": "4",
                            "name": "Solidity Security: Comprehensive list of known attack vectors and common anti-patterns - Delegatecall",
                            "link": "https://blog.sigmaprime.io/solidity-security.html#delegatecall"
                        }
                    ]
                },
                {
                    "id": "T0006",
                    "title": "Reentrancy",
                    "description": "One of the major dangers of calling external contracts is that they can take over the control flow. In the reentrancy attack (a.k.a. recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways.",
                    "to": "/T0006",
                    "examples": [
                        {
                            "id": "EX0006",
                            "title": "DAO incident",
                            "description": "The ETH DAO incident refers to a significant exploitation event in which a vulnerability in the DAO (Decentralized Autonomous Organization) smart contract on the Ethereum blockchain was manipulated, leading to the unauthorized diversion of 3.6 million Ether, raising critical discussions and reforms concerning smart contract security and blockchain governance.",
                            "to": "/EX0006"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "SWC-107",
                            "link": "https://swcregistry.io/docs/SWC-107/"
                        },
                        {
                            "id": "2",
                            "name": "Ethereum Smart Contract Best Practices - Reentrancy",
                            "link": "https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/"
                        },
                        {
                            "id": "3",
                            "name": "Decentralized Application Security Project",
                            "link": "https://www.dasp.co/#item-1"
                        }
                    ]
                },
                {
                    "id": "T0007",
                    "title": "Multiple calls in a single transaction",
                    "description": "Avoid combining multiple calls in a single transaction, especially when calls are executed as part of a loop. External calls can fail accidentally or deliberately, which can cause a DoS condition in the contract. To minimize the damage caused by such failures, it is better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically (this also reduces the chance of problems with the gas limit).",
                    "to": "/T0007",
                    "examples": [
                        {
                            "id": "EX0007",
                            "title": "EXAMPLE 0007",
                            "description": "The for loop iterates over refundAddresses, which can grow indefinitely if enough addresses are pushed to the array. This can lead to out-of-gas errors because there might not be enough gas to complete the loop if the array becomes large.",
                            "to": "/EX0007"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "SWC-113",
                            "link": "https://swcregistry.io/docs/SWC-113/"
                        },
                        {
                            "id": "2",
                            "name": "Ethereum Smart Contract Best Practices - Favor pull over push for external calls",
                            "link": "https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/#favor-pull-over-push-for-external-calls"
                        }
                    ]
                },
                {
                    "id": "T0008",
                    "title": "Untrusted Transaction Relayer",
                    "description": "Only allow trusted users to relay transactions. Insufficient gas griefing attacks can be performed on contracts which accept data and use it in a sub-call on another contract. If the sub-call fails, either the whole transaction is reverted, or execution is continued. In the case of a relayer contract, the user who executes the transaction, the 'forwarder', can effectively censor transactions by using just enough gas to execute the transaction, but not enough for the sub-call to succeed.",
                    "to": "/T0008",
                    "examples": [
                        {
                            "id": "EX0008",
                            "title": "EXAMPLE 0008",
                            "description": "The Relayer contract provided is vulnerable mainly due to its reliance on the low-level call function for forwarding calls to another contract, specified as Target. The call function forwards all remaining gas by default. If the Target contract's execute function requires more gas than is provided, the call will fail. This is known as the 'insufficient gas griefing' attack vector, where a contract is called with just enough gas to execute expensive operations but not enough to complete them, leading to a denial of service.",
                            "to": "/EX0008"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "SWC-126",
                            "link": "https://swcregistry.io/docs/SWC-126/"
                        },
                        {
                            "id": "2",
                            "name": "Smart Contract Security Field Guide - Griefing",
                            "link": "https://scsfg.io/hackers/griefing/"
                        }
                    ]
                },
                {
                    "id": "T0009",
                    "title": "Incorrect Transaction Parameter",
                    "description": "If a user calls a contract with a function selector that matches more than one function due to an incorrect parameter, it can result in the wrong function being called. This is especially risky if one of the functions is meant to be restricted or handle sensitive logic. Moreover, Sending an incorrect function selector or malformed data can result in the fallback function being triggered if no other function matches the signature. If the fallback function is not properly secured, it could lead to unexpected behavior, including security vulnerabilities.",
                    "to": "/T0009",
                    "examples": [
                        {
                            "id": "EX0009",
                            "title": "EXAMPLE 0009",
                            "description": "Under Construction...",
                            "to": "/EX0009"
                        }
                    ]
                }
            ]
        },
        {
            "id": "TA0004",
            "title": "Privilege Escalation",
            "subTitle": "(Access Control)",
            "description": "Tactics involves exploiting vulnerabilities, misconfigurations, or features in smart contracts to gain higher-level privileges, allowing attackers more control and access to sensitive data and critical system components.",
            "to": "/TA0004",
            "created": "17 October 2018",
            "updated": "19 July 2019",
            "items": [
                {
                    "id": "T0010",
                    "title": "Default Function Visibility",
                    "description": "Functions that do not have a function visibility type specified are \"public\" by default. This can lead to a vulnerability if a developer forgot to set the visibility and a malicious user is able to make unauthorized or unintended state changes.",
                    "to": "/T0010",
                    "examples": [
                        {
                            "id": "EX0010",
                            "title": "EXAMPLE 0010",
                            "description": "The function declarations in lines 11 and 17 do not set the visibility of the functions. At least for Solidity 0.4.24 (as specified in the pragma statement), this means they will default to being treated as public. This allows anyone to call the _sendWinings() function and take the money. Instead, the fixed version below restricts the _sendWinnings() function visibility to internal, so it can only be activated by the WithdrawWinnings() function that enforces a check whether the sender actually met the presumed conditions to receive the money.",
                            "to": "/EX0010"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "SWC-100",
                            "link": "https://swcregistry.io/docs/SWC-100/"
                        },
                        {
                            "id": "2",
                            "name": "Smart Contract Security Field Guide - Visibility",
                            "link": "https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/visibility/"
                        }
                    ]
                },
                {
                    "id": "T0011",
                    "title": "Data Type Overflow",
                    "description": "An overflow/underflow happens when an arithmetic operation reaches the maximum or minimum size of a type. For instance if a number is stored in the uint8 type, it means that the number is stored in a 8 bits unsigned number ranging from 0 to 2^8-1. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits – either larger than the maximum or lower than the minimum representable value.",
                    "to": "/T0011",
                    "examples": [
                        {
                            "id": "EX0011",
                            "title": "EXAMPLE 0011",
                            "description": "The most straightforward example is a function that does not check for integer underflow, allowing you to withdraw an infinite amount of tokens",
                            "to": "/EX0011"
                        },
                        {
                            "id": "EX0101",
                            "title": "EXAMPLE 0101",
                            "description": "Because var will change itself to the smallest type needed to contain the assigned value, it will become an uint8 to hold the value 0. If the loop is meant to iterate more than 255 times, it will never reach that number and will stop when the execution runs out of gas",
                            "to": "/EX0101"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "SWC-101",
                            "link": "https://swcregistry.io/docs/SWC-101/"
                        },
                        {
                            "id": "2",
                            "name": "Smart Contract Security Field Guide - Insecure Arithmetic",
                            "link": "https://consensys.github.io/smart-contract-best-practices/attacks/insecure-arithmetic/"
                        }
                    ]
                },
                {
                    "id": "T0012",
                    "title": "Reinitializing Constructor",
                    "description": "Constructors are special functions that are called only once during the contract creation. They often perform critical, privileged actions such as setting the owner of the contract. Before Solidity version 0.4.22, the only way of defining a constructor was to create a function with the same name as the contract class containing it. A function meant to become a constructor becomes a normal, callable function if its name doesn't exactly match the contract name. This behavior sometimes leads to security issues, in particular when smart contract code is re-used with a different name but the name of the constructor function is not changed accordingly.",
                    "to": "/T0012",
                    "examples": [
                        {
                            "id": "EX0012",
                            "title": "EXAMPLE 0012",
                            "description": "The issue lies with the function missing(), which is intended to be the constructor but is not correctly named as one. In Solidity versions before 0.4.22, constructors were defined by creating a function with the same name as the contract. In this case, the contract is named Missing, but the constructor is named missing(). Since Solidity is case-sensitive, these are considered different names, and therefore missing() is not recognized as a constructor but rather as a regular public function that anyone can call. ",
                            "to": "/EX0012"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "SWC-118",
                            "link": "https://swcregistry.io/docs/SWC-118/"
                        },
                        {
                            "id": "2",
                            "name": "SigmaPrime - Constructors with Care",
                            "link": "https://blog.sigmaprime.io/solidity-security.html#constructors"
                        }
                    ]
                },
                {
                    "id": "T0013",
                    "title": "Ownable",
                    "description": "The \"onlyOwner\" vulnerability occurs when external actors manage to execute functions within a smart contract that should be restricted exclusively to the owner, potentially leading to unauthorized access or control over the contract's functions and assets.",
                    "to": "/T0013",
                    "examples": [
                        {
                            "id": "EX0013",
                            "title": "CoinLancer Token Bug",
                            "description": "This token misused the modifier onlyOwner() which results to potential access control vulnerability. The onlyOwner modifier of a smart contract implementation for Coinlancer (CL), an Ethereum ERC20 token, has a potential access control vulnerability. All contract users can access functions that use this onlyOwner modifier, because the comparison between msg.sender and owner is incorrect.",
                            "to": "/EX0013"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "CVE-2018-17111, onlyOwner issues in CL token",
                            "link": "https://github.com/TEAM-C4B/CVE-LIST/tree/master/CVE-2018-17111"
                        }
                    ]
                },
                {
                    "id": "T0014",
                    "title": "Default State Varibale Visibility",
                    "description": "Labeling the visibility explicitly makes it easier to catch incorrect assumptions about who can access the variable. Variables can be specified as being public, internal or private. Explicitly define visibility for all state variables.",
                    "to": "/default-state-varibale-visibility",
                    "examples": [
                        {
                            "id": "EX0014",
                            "title": "EXAMPLE 0014",
                            "description": "Variables can be specified as being public, internal or private. Explicitly define visibility for all state variables. Especially, private functions and state variables are only visible for the contract they are defined in and not in derived contracts. Note: Everything inside a contract is visible to all observers external to the blockchain, even Private variables.",
                            "to": "/EX0014"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "SWC-108",
                            "link": "https://swcregistry.io/docs/SWC-108/"
                        },
                        {
                            "id": "2",
                            "name": "Ethereum Smart Contract Best Practices - Visibility",
                            "link": "https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/visibility/"
                        }
                    ]
                },
                {
                    "id": "T0015",
                    "title": "Uninitialized Storage Pointer",
                    "description": "Uninitialized local storage variables can point to unexpected storage locations in the contract, which can lead to intentional or unintentional vulnerabilities. As of compiler version 0.5.0 and higher this issue has been systematically resolved as contracts with uninitialised storage pointers do no longer compile.",
                    "to": "/T0015",
                    "examples": [
                        {
                            "id": "EX0015",
                            "title": "EXAMPLE 0015",
                            "description": "The reason for changing Game game; to Game memory game; on line 39 pertains to how Solidity handles storage and memory. The original code, Game game;, by default, attempts to declare a state variable that should be stored in storage, which is costly and persistent across function calls and transactions. This is not necessary in this context because game is only needed temporarily within the function's scope.",
                            "to": "/EX0015"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "SWC-109",
                            "link": "https://swcregistry.io/docs/SWC-109/"
                        },
                        {
                            "id": "2",
                            "name": "SigmaPrime - Uninitialised Storage Pointers",
                            "link": "https://github.com/sigp/solidity-security-blog#unintialised-storage-pointers-1"
                        }
                    ]
                },
                {
                    "id": "T0017",
                    "title": "Authorization through tx.origin",
                    "description": "tx.origin is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable for authorization could make a contract vulnerable if an authorized account calls into a malicious contract. A call could be made to the vulnerable contract that passes the authorization check since tx.origin returns the original sender of the transaction which in this case is the authorized account. tx.origin should not be used for authorization. Use msg.sender instead.",
                    "to": "/T0017",
                    "examples": [
                        {
                            "id": "EX0017",
                            "title": "EXAMPLE 0017",
                            "description": "Contracts that use the tx.origin to authorize users are vulnerable to phishing attacks.",
                            "to": "/EX0017"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "SWC-115",
                            "link": "https://swcregistry.io/docs/SWC-115/"
                        },
                        {
                            "id": "2",
                            "name": "Solidity Documentation - tx.origin",
                            "link": "https://docs.soliditylang.org/en/develop/security-considerations.html#tx-origin"
                        },
                        {
                            "id": "3",
                            "name": "Ethereum Smart Contract Best Practices - Avoid using tx.origin",
                            "link": "https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/tx-origin/"
                        }
                    ]
                },
                {
                    "id": "T0018",
                    "title": "Arbitrary Write to Storage Location",
                    "description": "A smart contract's data (e.g., storing the owner of the contract) is persistently stored at some storage location (i.e., a key or address) on the EVM level. The contract is responsible for ensuring that only authorized user or contract accounts may write to sensitive storage locations. If an attacker is able to write to arbitrary storage locations of a contract, the authorization checks may easily be circumvented. This can allow an attacker to corrupt the storage; for instance, by overwriting a field that stores the address of the contract owner.",
                    "to": "/T0018",
                    "examples": [
                        {
                            "id": "EX0018",
                            "title": "EXAMPLE 0018",
                            "description": "The UpdateBonusCodeAt function allows direct updating of the bonusCodes array at a specified index. If an attacker can manipulate the array length (by underflowing it with the PopBonusCode function), they can set the length to an arbitrary large number. This can potentially allow an attacker to write to arbitrary storage locations in the contract by specifying an index that corresponds to other storage locations.",
                            "to": "/EX0018"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "SWC-124",
                            "link": "https://swcregistry.io/docs/SWC-124/"
                        },
                        {
                            "id": "2",
                            "name": "Entry to Underhanded Solidity Coding Contest 2017 (honorable mention)",
                            "link": "https://github.com/Arachnid/uscc/tree/master/submissions-2017/doughoyte"
                        }
                    ]
                }
            ]
        },
        {
            "id": "TA0005",
            "title": "Defense Evasion",
            "description": "deploy various techniques to avoid detection by security mechanisms, such as signature verification and if-condition detour.",
            "subTitle": "(condition detour)",
            "to": "/TA0005",
            "created": "17 October 2018",
            "updated": "19 July 2019",
            "items": [
                {
                    "id": "T0011",
                    "title": "Data Type Overflow",
                    "description": "An overflow/underflow happens when an arithmetic operation reaches the maximum or minimum size of a type. For instance if a number is stored in the uint8 type, it means that the number is stored in a 8 bits unsigned number ranging from 0 to 2^8-1. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits – either larger than the maximum or lower than the minimum representable value.",
                    "to": "/T0011",
                    "examples": [
                        {
                            "id": "EX0011",
                            "title": "EXAMPLE 0011",
                            "description": "The most straightforward example is a function that does not check for integer underflow, allowing you to withdraw an infinite amount of tokens",
                            "to": "/EX0011"
                        },
                        {
                            "id": "EX0101",
                            "title": "EXAMPLE 0101",
                            "description": "Because var will change itself to the smallest type needed to contain the assigned value, it will become an uint8 to hold the value 0. If the loop is meant to iterate more than 255 times, it will never reach that number and will stop when the execution runs out of gas",
                            "to": "/EX0101"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "SWC-101",
                            "link": "https://swcregistry.io/docs/SWC-101/"
                        },
                        {
                            "id": "2",
                            "name": "Smart Contract Security Field Guide - Insecure Arithmetic",
                            "link": "https://consensys.github.io/smart-contract-best-practices/attacks/insecure-arithmetic/"
                        }
                    ]
                },
                {
                    "id": "T0021",
                    "title": "Blockvalue as a Timestamp",
                    "description": "Contracts often need access to time values to perform certain types of functionality. Values such as block.timestamp, and block.number can give you a sense of the current time or a time delta, however, they are not safe to use for most purposes. \nIn the case of block.timestamp, developers often attempt to use it to trigger time-dependent events. As Ethereum is decentralized, nodes can synchronize time only to some degree. Moreover, malicious miners can alter the timestamp of their blocks, especially if they can gain advantages by doing so. However, miners can't set a timestamp smaller than the previous one (otherwise the block will be rejected), nor can they set the timestamp too far ahead in the future. Taking all of the above into consideration, developers can't rely on the preciseness of the provided timestamp. \nAs for block.number, considering the block time on Ethereum is generally about 14 seconds, it's possible to predict the time delta between blocks. However, block times are not constant and are subject to change for a variety of reasons, e.g. fork reorganisations and the difficulty bomb. Due to variable block times, block.number should also not be relied on for precise calculations of time.",
                    "to": "/T0021",
                    "examples": [
                        {
                            "id": "EX0021",
                            "title": "EXAMPLE 0021",
                            "description": "Under Construction...",
                            "to": "/EX0021"
                        }
                    ],
                    "reference": [
                        {
                            "id": "1",
                            "name": "SWC-116",
                            "link": "https://swcregistry.io/docs/SWC-116/"
                        }
                    ]
                },
                {
                    "id": "T0022",
                    "title": "Signature Malleability",
                    "description": "The implementation of a cryptographic signature system in Ethereum contracts often assumes that the signature is unique, but signatures can be altered without the possession of the private key and still be valid. The EVM specification defines several so-called 'precompiled' contracts one of them being ecrecover which executes the elliptic curve public key recovery. A malicious user can slightly modify the three values v, r and s to create other valid signatures. A system that performs signature verification on contract level might be susceptible to attacks if the signature is part of the signed message hash. Valid signatures could be created by a malicious user to replay previously signed messages.",
                    "to": "/T0022",
                    "examples": [
                        {
                            "id": "EX0022",
                            "title": "EXAMPLE 0022",
                            "description": "In Solidity, the ecrecover function is used to recover the public key (i.e., the address) from a signature. This function derives the address from a given hash and a signature, which depends on the v, r, and s values of the signature. If a signature is malleable, slight modifications to the r or s values can generate multiple valid signatures. Ethereum tries to enforce the uniqueness of signatures by restricting the s value to be less than half of the order of the Secp256k1 curve.",
                            "to": "/EX0022"
                        }
                    ],

                    "reference" : [
                        {
                        "id": "1",
                        "name": "SWC-117",
                        "link": "https://swcregistry.io/docs/SWC-117/"
                        }
                    ]
                },
                {
                    "id": "T0023",
                    "title": "Weak Randomness using Block Variables",
                    "description": "Ability to generate random numbers is very helpful in all kinds of applications. One obvious example is gambling DApps, where pseudo-random number generator is used to pick the winner. However, creating a strong enough source of randomness in Ethereum is very challenging. For example, use of block.timestamp is insecure, as a miner can choose to provide any timestamp within a few seconds and still get his block accepted by others. Use of blockhash, block.difficulty and other fields is also insecure, as they're controlled by the miner. If the stakes are high, the miner can mine lots of blocks in a short time by renting hardware, pick the block that has required block hash for him to win, and drop all others.",
                    "to": "/T0023",
                    "examples": [
                        {
                            "id": "EX0023",
                            "title": "EXAMPLE 0023",
                            "description": "Random numbers can be guessed by making exploit contract that use the same code including block number",
                            "to": "/EX0023"
                        }
                    ],

                    "reference" : [
                    {
                        "id": "1",
                        "name": "SWC-120",
                        "link": "https://swcregistry.io/docs/SWC-120/"
                    },
                    {
                        "id": "2",
                        "name": "CVE-2018-17968, Bad Randomness in Ruletkalo",
                        "link": "https://github.com/TEAM-C4B/CVE-LIST/tree/master/CVE-2018-17968"
                    }]
                },
                {
                    "id": "T0018",
                    "title": "Arbitrary Write to Storage Location",
                    "description": "A smart contract's data (e.g., storing the owner of the contract) is persistently stored at some storage location (i.e., a key or address) on the EVM level. The contract is responsible for ensuring that only authorized user or contract accounts may write to sensitive storage locations. If an attacker is able to write to arbitrary storage locations of a contract, the authorization checks may easily be circumvented. This can allow an attacker to corrupt the storage; for instance, by overwriting a field that stores the address of the contract owner.",
                    "to": "/T0018",
                    "examples": [
                        {
                            "id": "EX0018",
                            "title": "EXAMPLE 0018",
                            "description": "The UpdateBonusCodeAt function allows direct updating of the bonusCodes array at a specified index. If an attacker can manipulate the array length (by underflowing it with the PopBonusCode function), they can set the length to an arbitrary large number. This can potentially allow an attacker to write to arbitrary storage locations in the contract by specifying an index that corresponds to other storage locations.",
                            "to": "/EX0018"
                        }
                    ],

                    "reference" : [
                    {
                        "id": "1",
                        "name": "SWC-124",
                        "link": "https://swcregistry.io/docs/SWC-124/"
                    },
                    {                       
                        "id": "2",
                        "name": "Entry to Underhanded Solidity Coding Contest 2017 (honorable mention)",
                        "link": "https://github.com/Arachnid/uscc/tree/master/submissions-2017/doughoyte"
                    }]
                },
                {
                    "id": "T0024",
                    "title": "Arbitrary Access with Low Level Call (mstore, assign)",
                    "description": "Solidity supports function types. That is, a variable of function type can be assigned with a reference to a function with a matching signature. The function saved to such variable can be called just like a regular function. \nThe problem arises when a user has the ability to arbitrarily change the function type variable and thus execute random code instructions. As Solidity doesn't support pointer arithmetics, it's impossible to change such variable to an arbitrary value. However, if the developer uses assembly instructions, such as mstore or assign operator, in the worst case scenario an attacker is able to point a function type variable to any code instruction, violating required validations and required state changes.",
                    "to": "/T0024",
                    "examples": [
                        {
                            "id": "EX0024",
                            "title": "EXAMPLE 0024",
                            "description": "Attacker is able to point a function type variable to any code instruction, violating required validations and required state changes.",
                            "to": "/EX0024"
                        }
                    ],

                    "reference" : [
                    {
                        "id": "1",
                        "name": "SWC-127",
                        "link": "https://swcregistry.io/docs/SWC-127/"
                    },
                    {                       
                        "id": "2",
                        "name": "Solidity CTF",
                        "link": "https://medium.com/authio/solidity-ctf-part-2-safe-execution-ad6ded20e042"
                    }]
                },
                {
                    "id": "T0025",
                    "title": "Improper Verification of Cryptographic Signature",
                    "description": "It is sometimes necessary to perform signature verification in smart contracts to achieve better usability or to save gas cost. A secure implementation needs to protect against Signature Replay Attacks by for example keeping track of all processed message hashes and only allowing new message hashes to be processed. A malicious user could attack a contract without such a control and get message hash that was sent by another user processed multiple times.",
                    "to": "/T0025",
                    "reference" : [
                    {
                        "id": "1",
                        "name": "SWC-121",
                        "link": "https://swcregistry.io/docs/SWC-121/"
                    },
                    {                       
                        "id": "2",
                        "name": "Medium - Replay Attack Vulnerability in Ethereum Smart Contracts Introduced by transferProxy()",
                        "link": "https://medium.com/cypher-core/replay-attack-vulnerability-in-ethereum-smart-contracts-introduced-by-transferproxy-124bf3694e25"
                    }]
                },
                {
                    "id": "T0026",
                    "title": "Insecure Signature Verification",
                    "description": "It is a common pattern for smart contract systems to allow users to sign messages off-chain instead of directly requesting users to do an on-chain transaction because of the flexibility and increased transferability that this provides. Smart contract systems that process signed messages have to implement their own logic to recover the authenticity from the signed messages before they process them further. A limitation for such systems is that smart contracts can not directly interact with them because they can not sign messages. Some signature verification implementations attempt to solve this problem by assuming the validity of a signed message based on other methods that do not have this limitation. An example of such a method is to rely on msg.sender and assume that if a signed message originated from the sender address then it has also been created by the sender address. This can lead to vulnerabilities especially in scenarios where proxies can be used to relay transactions.",
                    "to": "/T0026",
                    "reference" : [
                    {
                        "id": "1",
                        "name": "SWC-122",
                        "link": "https://swcregistry.io/docs/SWC-122/"
                    },
                    {                       
                        "id": "2",
                        "name": "Consensys Diligence 0x Audit Report - Insecure signature validator",
                        "link": "https://github.com/ConsenSys/0x_audit_report_2018-07-23#32-mixinsignaturevalidator-insecure-signature-validator-signaturetypecaller"
                    }]
                },
                {
                    "id": "T0027",
                    "title": "Hash Collisions With Multiple Variable Length Arguments",
                    "description": "Using abi.encodePacked() with multiple variable length arguments can, in certain situations, lead to a hash collision. Since abi.encodePacked() packs all elements in order regardless of whether they're part of an array, you can move elements between arrays and, so long as all elements are in the same order, it will return the same encoding. In a signature verification situation, an attacker could exploit this by modifying the position of elements in a previous function call to effectively bypass authorization.",
                    "to": "/T0027",
                    "examples": [
                        {
                            "id": "EX0027",
                            "title": "EXAMPLE 0027",
                            "description": "Hash collison can be occurred in abi.encodePacked.",
                            "to": "/EX0027"
                        }
                    ],

                    "reference" : [
                    {
                        "id": "1",
                        "name": "SWC-133",
                        "link": "https://swcregistry.io/docs/SWC-133/"
                    },
                    {                       
                        "id": "2",
                        "name": "Solidity Non-standard Packed Mode",
                        "link": "https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html#non-standard-packed-mode"
                    }]
                },
                {
                    "id": "T0045",
                    "title": "Contract Detection with extcodesize",
                    "description": "Extcodesize(A) assembly function returns the size of the code at address A. If the extcodesize of address A is not 0, it is likely to be a contract address, since the contract address will contain the code area. However, when a contract is deployed in the blockchain, the blockchain first put the constructor and initialize code size as 0. So if the attacker calculate the random number in constructor, they can easily bypass a logic.",
                    "to": "/T0045",
                    "examples": [{
                        "id": "EX0103",
                        "title": "Greedy 599 with extcodesize",
                        "description": "When you use Extcodesize to find out the contract address, it can be detoured by constructor.",
                        "to": "/EX0103"
                    }],

                    "reference" : [
                    {                       
                        "id": "1",
                        "name": "CVE-2018-17877, Greedy 599 with Bad Randomness",
                        "link": "https://github.com/TEAM-C4B/CVE-LIST/tree/master/CVE-2018-17877"
                    }]
                }
            ]
        },
        {
            "id": "TA0006",
            "title": "Discovery and Collection",
            "description": "Discovery identifies and collects valuable information within the smart contracts, which can include user credentials, sensitive data, or details about the contract information",
            "to": "/TA0006",
            "created": "17 October 2018",
            "updated": "19 July 2019",
            "items": [
                {
                    "id": "T0028",
                    "title": "Smart Contract Private Key Discovery",
                    "description": "Private Key is discovered in the smart contract.",
                    "to": "/T0028"
                },
                {
                    "id": "T0029",
                    "title": "unencrypted Private Variable",
                    "description": "It is a common misconception that private type variables cannot be read. Even if your contract is not published, attackers can look at contract transactions to determine values stored in the state of the contract. For this reason, it's important that unencrypted private data is not stored in the contract code or state.",
                    "to": "/T0029",
                    "examples": [
                        {
                            "id": "EX0029",
                            "title": "EXAMPLE 0029",
                            "description": "Under Construction...",
                            "to": "/EX0029"
                        }
                    ],

                    "reference" : [
                    {
                        "id": "1",
                        "name": "SWC-136",
                        "link": "https://swcregistry.io/docs/SWC-136/"
                    },
                    {
                        "id": "2",
                        "name": "CVE-2018-15552, TheEthereumLottery",
                        "link": "https://github.com/TEAM-C4B/CVE-LIST/tree/master/CVE-2018-15552"
                    },
                    {
                        "id": "3",
                        "name": "Medium - Keeping secrets on Ethereum",
                        "link": "https://medium.com/solidified/keeping-secrets-on-ethereum-5b556c3bb1ee"
                    }]
                },
                {
                    "id": "T0030",
                    "title": "Block Variable",
                    "description": "Ability to generate random numbers is very helpful in all kinds of applications. One obvious example is gambling DApps, where pseudo-random number generator is used to pick the winner. However, creating a strong enough source of randomness in Ethereum is very challenging. For example, use of block.timestamp is insecure, as a miner can choose to provide any timestamp within a few seconds and still get his block accepted by others. Use of blockhash, block.difficulty and other fields is also insecure, as they're controlled by the miner. If the stakes are high, the miner can mine lots of blocks in a short time by renting hardware, pick the block that has required block hash for him to win, and drop all others.",
                    "to": "/T0030",
                    "examples": [
                        {
                            "id": "EX0030",
                            "title": "EXAMPLE 0030",
                            "description": "Under Construction...",
                            "to": "/EX0030"
                        }
                    ],

                    "reference" : [
                    {
                        "id": "1",
                        "name": "SWC-120",
                        "link": "https://swcregistry.io/docs/SWC-120/"
                    }]
                }
            ]
        },
        {
            "id": "TA0007",
            "title": "Impact",
            "description": "Impact tactic refers to the ultimate consequence or effect of the attack on the victim, which may involve data destruction, disruption of services, or financial loss, and it often aligns with the attacker's end goals",
            "to": "/TA0007",
            "created": "17 October 2018",
            "updated": "19 July 2019",
            "items": [
                {
                    "id": "T0032",
                    "title": "Transfer Smart Contract Balance",
                    "description": "This impact highlights the illicit transfer of Ether (or other tokens) from a smart contract's balance to the attacker's address. Successful exploitation might drain all the funds from a vulnerable smart contract.",
                    "to": "/T0032"
                },
                {
                    "id": "T0033",
                    "title": "Data Destruction",
                    "description": "Attackers might exploit vulnerabilities to erase or alter data stored in a smart contract, rendering it unusable or causing it to malfunction.",
                    "to": "/T0033"
                },
                {
                    "id": "T0034",
                    "title": "Storage Manipulation",
                    "description": "This impact refers to the unauthorized modification of a contract's storage variables. By tampering with storage, an attacker can potentially alter the contract's intended behavior.",
                    "to": "/T0034"
                },
                {
                    "id": "T0035",
                    "title": "DOS revert",
                    "description": "Attackers can force a contract to revert its transactions, essentially denying service. This is often done by exploiting vulnerabilities that cause a contract to throw exceptions or errors.",
                    "to": "/T0035"
                },
                {
                    "id": "T0036",
                    "title": "Out of Gas Limit",
                    "description": "By forcing complex computations or exploiting vulnerabilities, an attacker might cause a contract to exceed its gas limit, terminating its execution.",
                    "to": "/T0036"
                },
                {
                    "id": "T0037",
                    "title": "SELFDESTRUCT",
                    "description": "In Solidity, the selfdestruct function is used to remove a contract from the blockchain. When a contract calls this function, it causes the contract to be destroyed and removed from the Ethereum blockchain after the current execution context completes.",
                    "to": "/T0037",
                    "reference" : [
                    {
                        "id": "1",
                        "name": "SWC-106",
                        "link": "https://swcregistry.io/docs/SWC-106/"
                    },
                    {
                        "id": "2",
                        "name": "Parity \"I accidentally killed it\" bug",
                        "link": "https://www.parity.io/blog/a-postmortem-on-the-parity-multi-sig-library-self-destruct/"
                    }]
                }
            ]
        },
        {
            "id": "TA0008",
            "title": "Managing",
            "description": "Tactics involves different methods and services that send cryptocurrency through numerous addresses or businesses to obscure their origins",
            "to": "/TA0008",
            "created": "17 October 2018",
            "updated": "19 July 2019",
            "items": [
                {
                    "id": "T0038",
                    "title": "Zero-Knowledge Proofs(ZKPs)",
                    "description": "Zero-Knowledge Proofs (ZKPs) are cryptographic methods that allow one party to prove to another that a given statement is true, without revealing any specific information about the statement itself, ensuring both correctness and privacy.",
                    "to": "/T0038",
                    "examples": [
                        {
                            "id": "EX0038",
                            "title": "EXAMPLE 0038",
                            "description": "Under Construction...",
                            "to": "/EX0038"
                        }
                    ]
                },
                {
                    "id": "T0039",
                    "title": "Mixers",
                    "description": "Mixers refer to services or protocols that blend different transactions or sources of coins together, obfuscating their origins to enhance transactional privacy and impede transaction graph analysis.",
                    "to": "/T0039",
                    "examples": [
                        {
                            "id": "EX0039",
                            "title": "EXAMPLE 0039",
                            "description": "Under Construction...",
                            "to": "/EX0039"
                        }
                    ]
                },
                {
                    "id": "T0040",
                    "title": "Coin-Swap",
                    "description": "Coin-Swap is a mechanism that allows two parties to exchange their cryptocurrencies in a trustless manner, ensuring that neither party can cheat the other, and, in some implementations, preserving the privacy of the transaction history.",
                    "to": "/T0040",
                    "examples": [
                        {
                            "id": "EX0040",
                            "title": "EXAMPLE 0040",
                            "description": "Under Construction...",
                            "to": "/T0040"
                        }
                    ]
                },
                {
                    "id": "T0041",
                    "title": "OTC Broker",
                    "description": "Over-The-Counter (OTC) broker act as an intermediary to facilitate high-volume transactions outside of regulated exchanges, potentially allowing for obfuscation of the origin and flow of illicit funds.",
                    "to": "/T0041",
                    "examples": [
                        {
                            "id": "EX0041",
                            "title": "EXAMPLE 0041",
                            "description": "Under Construction...",
                            "to": "/T0041"
                        }
                    ]
                }
            ]
        }
    ]
}